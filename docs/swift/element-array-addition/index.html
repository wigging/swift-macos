<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link href="https://gavinw.me/swift-macos/rss.xml" rel="alternate" type="application/rss+xml" title="RSS">
    <link href="https://gavinw.me/swift-macos/styles.css" rel="stylesheet">
    <title>Swift macOS</title>
</head>
<body>
<div class="container">
    
<div class="row">
<div class="col">
    <h1>Element-wise array addition</h1>
    
        <h6>January 16, 2023</h6>
    
    <hr>
    <p>There are several ways to perform element-wise array addition with Swift arrays. One approach is to use a for-loop, another approach is to use the Accelerate framework, and yet another approach is to use a Metal GPU compute kernel. An example of each approach is given below and an elapsed time comparison for adding two large arrays is given in the Summary section.</p>
<h2 id="using-swift">Using Swift</h2>
<p>Adding elements of two arrays using pure Swift is demonstrated below using a for-loop. This can be slow for large arrays.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">let</span><span> x: [Float] = [</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>.</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">8</span><span>]
</span><span style="color:#b48ead;">let</span><span> y: [Float] = [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">1</span><span>.</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">7</span><span>.</span><span style="color:#d08770;">4</span><span>]
</span><span>
</span><span style="color:#b48ead;">var</span><span> z = [Float](repeating: </span><span style="color:#d08770;">0</span><span>, count: x.count)
</span><span>
</span><span style="color:#b48ead;">for</span><span> i </span><span style="color:#b48ead;">in </span><span style="color:#d08770;">0</span><span>..&lt;x.count {
</span><span>    z[i] = x[i] + y[i]
</span><span>}
</span><span>
</span><span style="color:#65737e;">// This gives the following
</span><span style="color:#65737e;">// z is [5.0, 5.7, 15.4]
</span></code></pre>
<p>This function prints out the elapsed time of this approach and the first three results.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>Foundation
</span><span>
</span><span style="color:#b48ead;">func </span><span>addSwift(_ arr1: [Float], _ arr2: [Float]) {
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> tic = CFAbsoluteTimeGetCurrent()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Add two arrays and store results
</span><span>    </span><span style="color:#b48ead;">let</span><span> count = arr1.count
</span><span>    </span><span style="color:#b48ead;">var</span><span> result = [Float](repeating: </span><span style="color:#d08770;">0</span><span>.</span><span style="color:#d08770;">0</span><span>, count: count)
</span><span>
</span><span>    </span><span style="color:#b48ead;">for</span><span> i </span><span style="color:#b48ead;">in </span><span style="color:#d08770;">0</span><span>..&lt;count {
</span><span>        result[i] = arr1[i] + arr2[i]
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out the elapsed time
</span><span>    </span><span style="color:#b48ead;">let</span><span> toc = CFAbsoluteTimeGetCurrent()
</span><span>    print(</span><span style="color:#a3be8c;">&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">Swift elapsed time is </span><span>\(toc - tic) </span><span style="color:#a3be8c;">s&quot;</span><span>)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out some results
</span><span>    </span><span style="color:#b48ead;">for</span><span> i </span><span style="color:#b48ead;">in </span><span style="color:#d08770;">0</span><span>..&lt;</span><span style="color:#d08770;">3</span><span> {
</span><span>        </span><span style="color:#b48ead;">let</span><span> a1 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr1[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> a2 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr2[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> y = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, result[i])
</span><span>        print(</span><span style="color:#a3be8c;">&quot;</span><span>\(a1) </span><span style="color:#a3be8c;">+ </span><span>\(a2) </span><span style="color:#a3be8c;">= </span><span>\(y)</span><span style="color:#a3be8c;">&quot;</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="using-accelerate">Using Accelerate</h2>
<p>Element-wise array addition can be accomplished with the Accelerate vDSP.add function as shown below. This approach offers massive speed improvements for large arrays compared to adding the elements in a for-loop.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>Accelerate
</span><span>
</span><span style="color:#b48ead;">let</span><span> x: [Float] = [</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>.</span><span style="color:#d08770;">5</span><span>, </span><span style="color:#d08770;">8</span><span>]
</span><span style="color:#b48ead;">let</span><span> y: [Float] = [</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">1</span><span>.</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">7</span><span>.</span><span style="color:#d08770;">4</span><span>]
</span><span style="color:#b48ead;">let</span><span> z = vDSP.add(x, y)
</span><span>
</span><span style="color:#65737e;">// where z is [5.0, 5.7, 15.4]
</span></code></pre>
<p>The Accelerate framework provides the vDSP.add function to add elements of two arrays. This approach provides a significant speed boost for adding large arrays.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>Accelerate
</span><span>
</span><span style="color:#b48ead;">func </span><span>addAccel(_ arr1: [Float], _ arr2: [Float]) {
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> tic = CFAbsoluteTimeGetCurrent()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Add two arrays and store results
</span><span>    </span><span style="color:#b48ead;">let</span><span> y = vDSP.add(arr1, arr2)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out elapsed time
</span><span>    </span><span style="color:#b48ead;">let</span><span> toc = CFAbsoluteTimeGetCurrent()
</span><span>    print(</span><span style="color:#a3be8c;">&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">Accelerate vDSP elapsed time is </span><span>\(toc - tic) </span><span style="color:#a3be8c;">s&quot;</span><span>)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out some results
</span><span>    </span><span style="color:#b48ead;">for</span><span> i </span><span style="color:#b48ead;">in </span><span style="color:#d08770;">0</span><span>..&lt;</span><span style="color:#d08770;">3</span><span> {
</span><span>        </span><span style="color:#b48ead;">let</span><span> a1 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr1[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> a2 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr2[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> y = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, y[i])
</span><span>        print(</span><span style="color:#a3be8c;">&quot;</span><span>\(a1) </span><span style="color:#a3be8c;">+ </span><span>\(a2) </span><span style="color:#a3be8c;">= </span><span>\(y)</span><span style="color:#a3be8c;">&quot;</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="using-metal">Using Metal</h2>
<p>The Metal compute kernal for adding the elements of two arrays is given below.</p>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">#include </span><span>&lt;</span><span style="color:#a3be8c;">metal_stdlib</span><span>&gt;
</span><span style="color:#b48ead;">using namespace</span><span> metal;
</span><span>
</span><span>kernel </span><span style="color:#b48ead;">void </span><span style="color:#8fa1b3;">adder</span><span>(
</span><span>                  constant </span><span style="color:#b48ead;">float </span><span>*</span><span style="color:#bf616a;">array1 </span><span>[[ </span><span style="color:#bf616a;">buffer</span><span>(</span><span style="color:#d08770;">0</span><span>) ]],
</span><span>                  constant </span><span style="color:#b48ead;">float </span><span>*</span><span style="color:#bf616a;">array2 </span><span>[[ </span><span style="color:#bf616a;">buffer</span><span>(</span><span style="color:#d08770;">1</span><span>) ]],
</span><span>                  device </span><span style="color:#b48ead;">float </span><span>*</span><span style="color:#bf616a;">result </span><span>[[ </span><span style="color:#bf616a;">buffer</span><span>(</span><span style="color:#d08770;">2</span><span>) ]],
</span><span>                  uint </span><span style="color:#bf616a;">index </span><span>[[ thread_position_in_grid ]])
</span><span>{
</span><span>    result[index] = array1[index] + array2[index];
</span><span>}
</span></code></pre>
<p>Next, the adder kernel function is implemented in the Metal compute pipeline as shown below.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>MetalKit
</span><span>
</span><span style="color:#b48ead;">private func </span><span>setupMetal(arr1: [Float], arr2: [Float]) -&gt; (MTLCommandBuffer?, MTLBuffer?) {
</span><span>
</span><span>    </span><span style="color:#65737e;">// Get the Metal GPU device
</span><span>    </span><span style="color:#b48ead;">let</span><span> device = MTLCreateSystemDefaultDevice()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Queue for sending commands to the GPU
</span><span>    </span><span style="color:#b48ead;">let</span><span> commandQueue = device?.makeCommandQueue()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Get our Metal GPU function
</span><span>    </span><span style="color:#b48ead;">let</span><span> gpuFunctionLibrary = device?.makeDefaultLibrary()
</span><span>    </span><span style="color:#b48ead;">let</span><span> adderGpuFunction = gpuFunctionLibrary?.makeFunction(name: </span><span style="color:#a3be8c;">&quot;adder&quot;</span><span>)
</span><span>
</span><span>    </span><span style="color:#b48ead;">var</span><span> pipelineState: MTLComputePipelineState!
</span><span>    do {
</span><span>        pipelineState = </span><span style="color:#b48ead;">try</span><span> device?.makeComputePipelineState(function: adderGpuFunction!)
</span><span>    } catch {
</span><span>      print(error)
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#65737e;">// Create the buffers to be sent to the GPU from our arrays
</span><span>    </span><span style="color:#b48ead;">let</span><span> count = arr1.count
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> arr1Buff = device?.makeBuffer(bytes: arr1,
</span><span>                                      length: MemoryLayout&lt;Float&gt;.size * count,
</span><span>                                      options: .storageModeShared)
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> arr2Buff = device?.makeBuffer(bytes: arr2,
</span><span>                                      length: MemoryLayout&lt;Float&gt;.size * count,
</span><span>                                      options: .storageModeShared)
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> resultBuff = device?.makeBuffer(length: MemoryLayout&lt;Float&gt;.size * count,
</span><span>                                        options: .storageModeShared)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Create a buffer to be sent to the command queue
</span><span>    </span><span style="color:#b48ead;">let</span><span> commandBuffer = commandQueue?.makeCommandBuffer()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Create an encoder to set values on the compute function
</span><span>    </span><span style="color:#b48ead;">let</span><span> commandEncoder = commandBuffer?.makeComputeCommandEncoder()
</span><span>    commandEncoder?.setComputePipelineState(pipelineState)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Set the parameters of our GPU function
</span><span>    commandEncoder?.setBuffer(arr1Buff, offset: </span><span style="color:#d08770;">0</span><span>, index: </span><span style="color:#d08770;">0</span><span>)
</span><span>    commandEncoder?.setBuffer(arr2Buff, offset: </span><span style="color:#d08770;">0</span><span>, index: </span><span style="color:#d08770;">1</span><span>)
</span><span>    commandEncoder?.setBuffer(resultBuff, offset: </span><span style="color:#d08770;">0</span><span>, index: </span><span style="color:#d08770;">2</span><span>)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Figure out how many threads we need to use for our operation
</span><span>    </span><span style="color:#b48ead;">let</span><span> threadsPerGrid = MTLSize(width: count, height: </span><span style="color:#d08770;">1</span><span>, depth: </span><span style="color:#d08770;">1</span><span>)
</span><span>    </span><span style="color:#b48ead;">let</span><span> maxThreadsPerThreadgroup = pipelineState.maxTotalThreadsPerThreadgroup
</span><span>    </span><span style="color:#b48ead;">let</span><span> threadsPerThreadgroup = MTLSize(width: maxThreadsPerThreadgroup, height: </span><span style="color:#d08770;">1</span><span>, depth: </span><span style="color:#d08770;">1</span><span>)
</span><span>    commandEncoder?.dispatchThreads(threadsPerGrid, threadsPerThreadgroup: threadsPerThreadgroup)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Tell the encoder that it is done encoding. Now we can send this off to the GPU.
</span><span>    commandEncoder?.endEncoding()
</span><span>
</span><span>    </span><span style="color:#b48ead;">return</span><span> (commandBuffer, resultBuff)
</span><span>}
</span><span>
</span><span style="color:#b48ead;">func </span><span>addMetal(_ arr1: [Float], _ arr2: [Float]) {
</span><span>
</span><span>    </span><span style="color:#b48ead;">let</span><span> (commandBuffer, resultBuff) = setupMetal(arr1: arr1, arr2: arr2)
</span><span>    </span><span style="color:#b48ead;">let</span><span> tic = CFAbsoluteTimeGetCurrent()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Push this command to the command queue for processing
</span><span>    commandBuffer?.commit()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Wait until the GPU function completes before working with any of the data
</span><span>    commandBuffer?.waitUntilCompleted()
</span><span>
</span><span>    </span><span style="color:#65737e;">// Get the pointer to the beginning of our data
</span><span>    </span><span style="color:#b48ead;">let</span><span> count = arr1.count
</span><span>    </span><span style="color:#b48ead;">var</span><span> resultBufferPointer = resultBuff?.contents().bindMemory(to: Float.</span><span style="color:#b48ead;">self</span><span>, capacity: count)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out elapsed time
</span><span>    </span><span style="color:#b48ead;">let</span><span> toc = CFAbsoluteTimeGetCurrent()
</span><span>    print(</span><span style="color:#a3be8c;">&quot;</span><span style="color:#96b5b4;">\n</span><span style="color:#a3be8c;">Metal GPU elapsed time is </span><span>\(toc - tic) </span><span style="color:#a3be8c;">s&quot;</span><span>)
</span><span>
</span><span>    </span><span style="color:#65737e;">// Print out the results
</span><span>    </span><span style="color:#b48ead;">for</span><span> i </span><span style="color:#b48ead;">in </span><span style="color:#d08770;">0</span><span>..&lt;</span><span style="color:#d08770;">3</span><span> {
</span><span>        </span><span style="color:#b48ead;">let</span><span> a1 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr1[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> a2 = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, arr2[i])
</span><span>        </span><span style="color:#b48ead;">let</span><span> y = String(format: </span><span style="color:#a3be8c;">&quot;%.4f&quot;</span><span>, Float(resultBufferPointer!.pointee))
</span><span>        print(</span><span style="color:#a3be8c;">&quot;</span><span>\(a1) </span><span style="color:#a3be8c;">+ </span><span>\(a2) </span><span style="color:#a3be8c;">= </span><span>\(y)</span><span style="color:#a3be8c;">&quot;</span><span>)
</span><span>        resultBufferPointer = resultBufferPointer?.advanced(by: </span><span style="color:#d08770;">1</span><span>)
</span><span>    }
</span><span>}
</span></code></pre>
<p>The main Swift file for running this Metal example is shown below.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>Foundation
</span><span>
</span><span style="color:#65737e;">// Size of each array
</span><span style="color:#b48ead;">private let</span><span> n = </span><span style="color:#d08770;">5_000_000
</span><span>
</span><span style="color:#65737e;">// Create two random arrays of size n
</span><span style="color:#b48ead;">private let</span><span> array1 = (</span><span style="color:#d08770;">1</span><span>...n).map{ _ </span><span style="color:#b48ead;">in </span><span>Float.random(</span><span style="color:#b48ead;">in</span><span>: </span><span style="color:#d08770;">1</span><span>...</span><span style="color:#d08770;">10</span><span>) }
</span><span style="color:#b48ead;">private let</span><span> array2 = (</span><span style="color:#d08770;">1</span><span>...n).map{ _ </span><span style="color:#b48ead;">in </span><span>Float.random(</span><span style="color:#b48ead;">in</span><span>: </span><span style="color:#d08770;">1</span><span>...</span><span style="color:#d08770;">10</span><span>) }
</span><span>
</span><span style="color:#65737e;">// Add two arrays using Metal on the GPU
</span><span>addMetal(array1, array2)
</span></code></pre>
<h2 id="comparison">Comparison</h2>
<p>The main file for running the above examples is shown below. The table gives elapsed times from running the example code on a MacBook Pro with a 2.6 GHz 6-core Intel i7 CPU, 32 GB of RAM, and a 4 GB AMD Radeon Pro 5500m GPU. Before running the Xcode project, the GPU Frame Capture and API Validation were disabled for Metal. Based on the results, the Accelerate function is the fastest and the Swift for-loop is the slowest when adding two arrays with 5,000,000 elements.</p>
<pre data-lang="swift" style="background-color:#2b303b;color:#c0c5ce;" class="language-swift "><code class="language-swift" data-lang="swift"><span style="color:#b48ead;">import </span><span>Foundation
</span><span>
</span><span style="color:#65737e;">// Size of each array
</span><span style="color:#b48ead;">private let</span><span> n = </span><span style="color:#d08770;">5_000_000
</span><span>
</span><span style="color:#65737e;">// Create two random arrays of size n
</span><span style="color:#b48ead;">private let</span><span> array1 = (</span><span style="color:#d08770;">1</span><span>...n).map{ _ </span><span style="color:#b48ead;">in </span><span>Float.random(</span><span style="color:#b48ead;">in</span><span>: </span><span style="color:#d08770;">1</span><span>...</span><span style="color:#d08770;">10</span><span>) }
</span><span style="color:#b48ead;">private let</span><span> array2 = (</span><span style="color:#d08770;">1</span><span>...n).map{ _ </span><span style="color:#b48ead;">in </span><span>Float.random(</span><span style="color:#b48ead;">in</span><span>: </span><span style="color:#d08770;">1</span><span>...</span><span style="color:#d08770;">10</span><span>) }
</span><span>
</span><span style="color:#65737e;">// Add two arrays using Swift
</span><span>addSwift(array1, array2)
</span><span>
</span><span style="color:#65737e;">// Add two arrays using Accelerate vDSP
</span><span>addAccel(array1, array2)
</span><span>
</span><span style="color:#65737e;">// Add two arrays using Metal on the GPU
</span><span>addMetal(array1, array2)
</span></code></pre>
<table class="table table-dark table-hover">
    <thead>
        <tr>
            <th scope="col">Method</th>
            <th scope="col">Elapsed time (s)</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Swift</td>
            <td>3.3896</td>
        </tr>
        <tr>
            <td>Accelerate</td>
            <td>0.006299</td>
        </tr>
        <tr>
            <td>Metal</td>
            <td>0.01030</td>
        </tr>
    </tbody>
</table>

</div>
</div>
<div class="row my-5">
<div class="col">
    <p class="text-center small my-5">
        <a href="https://gavinw.me/swift-macos/">Swift Programming for macOS</a> Â© 2023 <br>
        Built by <a href="https://gavinw.me">Gavin Wiggins</a>
    </p>
</div>
</div>

</div>
</body>
</html>